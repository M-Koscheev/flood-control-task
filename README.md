Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Описание решения:
В качестве базы данных я выбрал Redis. Redis выигрывает в скорости и проигрывает в надежности (тому же PostgreSQL). Так как данные, которые мы планируем хранить не являются критическими, то мы можем позволить себе их потерю в случае отключения сервера. 

Было решено обновлять значение пользователя после истечения TTL:  изначально я планировал хранить очереди с датами с элементами (время последнего сообщения + время жизни сообщения), это посволило бы точнее отслеживать точное количество сообщений пользователя за указанный период. От этого решения я отказался из-за нецелесообразной сложности реализации, а также лишним затратам памяти и времени выполнения программы. Реализованный способ сочетает в себе простоту - по истечении срока ключ удаляется, и работоспособность - программа все еще способна находить флуд в сообщениях.

В проекте реализованы конфигурации, а именно:
  
  timeToLive - время жизни сообщений
    
  maxMeetings - максимальное количество сообщений, не являющееся флудом
